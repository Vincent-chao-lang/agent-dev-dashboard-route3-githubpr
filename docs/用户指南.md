# Agent Dev Dashboard 用户指南

## 📖 目录

1. [系统简介](#系统简介)
2. [快速开始](#快速开始)
3. [核心概念](#核心概念)
4. [使用流程](#使用流程)
5. [角色与权限](#角色与权限)
6. [LLM 集成与配置](#llm-集成与配置)
7. [ADSE 增强模式](#adse-增强模式)
8. [质量门禁](#质量门禁)
9. [GitHub 集成](#github-集成)
10. [最佳实践](#最佳实践)
11. [实战案例](#实战案例为电商系统添加用户评论功能)
12. [常见问题](#常见问题)
13. [获取帮助](#获取帮助)

---

## 系统简介

Agent Dev Dashboard 是一个**多 Agent 协作开发工作台**，集成了智谱 GLM-4.7 大模型，通过标准化流程、产物约束、质量门禁和完整审计，将大模型 Agent 的风险降到可控范围。

### 核心理念

> **"大模型 Agent 可以做很多过去要人做的工作，但要靠 SOP、产物约束、门禁、审计记录来把风险降到可控"**

- **多 Agent 并行**：AI 辅助生成需求文档、架构设计、代码实现、测试用例、运维文档
- **人类总指挥**：设定目标、验收标准、审核 AI 产出、合并发布
- **工具价值**：流程固定化、输出结构化、错误可追溯

### 主要特性

| 特性 | 说明 |
|------|------|
| 🤖 **GLM-4.7 集成** | 所有 Agent 使用智谱 GLM-4.7 生成专业文档 |
| 🔐 **用户认证** | 本地账户系统，支持邀请码注册 |
| 👥 **团队协作** | 项目成员管理，支持 Owner 和 Member 角色 |
| 🔄 **Git 隔离** | 基于 Git Worktree 的独立开发环境 |
| ⚙️ **灵活配置** | 支持用户级、项目级、全局 LLM 配置 |
| 🚀 **ADSE 增强** | 可选的四象限需求法，提升 AI 生成代码质量 |
| ✅ **质量门禁** | Lint、Type Check、Contract、Test 自动化检查 |
| 🔀 **GitHub PR** | 自动创建 PR 并推送门禁结果 |
| 🌐 **多语言** | 支持中英文界面切换 |
| 📝 **完整审计** | 所有操作全量记录，可追溯 |

### 核心价值

Agent Dev Dashboard 是一个**AI 增强的开发工具**：

✅ **GLM-4.7 智能辅助**：AI 生成专业文档和代码框架
✅ **三层配置**：灵活的费用核算和配置管理
✅ **邀请码系统**：受控的用户注册
✅ **多语言支持**：中英文界面
✅ **不追求完全自动化**：增强人类能力而非替代
✅ **不隐藏风险**：通过流程控制风险
✅ **不替代人类**：让人类专注于创意和决策

**核心价值**：
1. AI 加速：GLM-4.7 生成高质量初稿
2. 流程固定化：减少沟通成本
3. 输出结构化：提高协作效率
4. 错误可追溯：降低风险

---

## 快速开始

### 环境要求

- Python 3.8+
- Git
- 智谱 AI API Key（用于 GLM-4.7）

### 安装步骤

```bash
# 1. 克隆项目
git clone <repository-url>
cd agent-dev-dashboard-route3-githubpr

# 2. 安装依赖
pip install -r requirements.txt

# 3. 配置环境变量
cp .env.example .env
# 编辑 .env 文件，填入你的智谱 AI API Key
```

### 配置 LLM API Key

编辑 `.env` 文件：

```bash
# 必需配置
LLM_API_KEY=your-zhipuai-api-key-here
LLM_BASE_URL=https://open.bigmodel.cn/api/paas/v4/
LLM_MODEL=glm-4-plus

# 可选配置
LLM_TEMPERATURE=0.7
LLM_MAX_TOKENS=4096

# 其他配置
APP_DB_PATH=./dashboard.sqlite
WORKSPACE_DIR=./workspace
SESSION_SECRET=your-secret-key
```

### 获取智谱 AI API Key

1. 访问 [智谱 AI 开放平台](https://open.bigmodel.cn/)
2. 注册/登录账户
3. 在 API Keys 页面创建新的 API Key
4. 将 API Key 复制到 `.env` 文件中

### 启动服务

```bash
python -m app.main
```

服务默认运行在 `http://localhost:8000`

### 首次使用

1. 访问 `http://localhost:8000`
2. 创建首个用户账户（仅第一个用户可注册）
3. 登录系统
4. （可选）配置个人 LLM 设置

---

## 核心概念

### Project（项目）

项目对应一个 Git 仓库，是开发活动的基本组织单位。

### Slice（开发切片）

Slice 代表一个独立的开发任务或功能点，是实际的工作单元。

### LLM 配置层级

系统支持三层 LLM 配置，优先级从高到低：

```
1. 用户级配置
     ↓ (如果用户配置存在且有效)

2. 项目级配置
     ↓ (如果项目配置存在且有效)

3. 全局配置（.env 文件）
     ↓ (默认配置)

有效配置 = 最高优先级的有效配置
```

**配置优先级示例**：

| 场景 | 用户配置 | 项目配置 | 全局配置 | 最终使用 |
|------|----------|----------|----------|----------|
| Alice 设置了个人 API Key | ✅ | ❌ | ✅ | Alice 的配置 |
| Alice 没设置，项目有配置 | ❌ | ✅ | ✅ | 项目配置 |
| Alice 和项目都没设置 | ❌ | ❌ | ✅ | 全局配置 |
| Alice 设置了个人 API Key，项目也有 | ✅ | ✅ | ✅ | Alice 的配置（优先） |

### Context Pack（上下文包）

AI Agent 执行时所需的完整上下文信息。

### Run（执行记录）

每次 Agent 运行或门禁检查都会创建一个 Run 记录。

---

## 使用流程

### 1. 创建项目

```
首页 → 创建项目
```

### 2. 配置 LLM（可选）

**方式一：全局配置**（推荐个人使用）

1. 编辑 `.env` 文件
2. 设置 `LLM_API_KEY` 和其他配置

**方式二：用户级配置**（推荐团队使用）

1. 点击顶部导航栏的 "Settings"
2. 填写个人 LLM 配置
3. 保存配置

**方式三：项目级配置**（推荐项目隔离）

1. 进入项目详情页（仅 Owner 可见）
2. 在 LLM Configuration 区块填写配置
3. 保存配置

### 3. 添加团队成员

### 4. 创建 Slice

### 5. 设定验收标准

### 6. 生成上下文包

```
Slice 详情页 → Actions → Generate Context Pack
```

### 7. 执行角色 Agent（AI 辅助）

```
Slice 详情页 → Roles → 选择角色 → Run
```

各 Agent 使用 GLM-4.7 生成专业文档：

| 角色 | AI 生成内容 | 可写路径 |
|------|------------|----------|
| **PM** | PRD 文档、任务卡片、验收标准 | `docs/`, `tasks/` |
| **Architect** | 技术设计文档、API 契约、测试策略 | `docs/`, `contracts/` |
| **Dev** | 开发报告、实施计划、代码框架 | `src/`, `tests/unit/`, `reports/` |
| **QA** | 测试计划、测试用例代码、测试报告 | `tests/`, `docker/`, `reports/` |
| **Ops** | 部署文档、运维手册、资源清单 | `docs/`, `reports/` |

**AI 生成特点**：
- 使用智谱 GLM-4.7 大模型
- 根据项目现有代码风格生成
- 遵循验收标准和范围定义
- 支持 fallback 机制（API 调用失败时使用模板）

### 8. 运行质量门禁

### 9. 创建 GitHub PR

---

## 角色与权限

### 用户角色

| 角色 | 权限 |
|------|------|
| **Owner** | 项目管理、成员添加、邀请码生成、所有操作 |
| **Member** | Slice 创建、Agent 执行、门禁运行 |
| **Readonly** | 仅查看 |

### 邀请码系统

**项目所有者可以生成邀请码**：

1. 进入项目详情页
2. 在 Invitations 区块设置有效期
3. 点击 "Create Invitation" 生成邀请码
4. 将邀请码分享给新用户
5. 新用户使用邀请码注册

**注册流程**：

```
首个用户 → 直接注册（无需邀请码）
后续用户 → 使用邀请码注册
```

---

## LLM 集成与配置

### GLM-4.7 大模型

系统默认使用智谱 GLM-4.7（glm-4-plus）为所有 Agent 提供智能生成能力。

### 配置层级详解

#### 1. 全局配置（.env 文件）

适用于：
- 个人使用
- 团队初期
- 测试环境

```bash
# .env 文件
LLM_API_KEY=your-global-api-key
LLM_BASE_URL=https://open.bigmodel.cn/api/paas/v4/
LLM_MODEL=glm-4-plus
LLM_TEMPERATURE=0.7
LLM_MAX_TOKENS=4096
```

#### 2. 用户级配置（推荐）

适用于：
- 多人团队
- 个人费用核算
- 灵活配置

**配置路径**：`/settings` → LLM Configuration

**特点**：
- 每个用户使用自己的 API Key
- 费用独立计算
- 优先级高于项目配置

#### 3. 项目级配置

适用于：
- 项目独立核算
- 客户项目
- 特殊模型需求

**配置路径**：项目详情页 → LLM Configuration（仅 Owner 可见）

**特点**：
- 项目成员共享同一配置
- 按项目核算成本
- 优先级低于用户配置

### 配置优先级示例

**场景 1：Alice 使用自己的 API Key**

```
全局配置：团队共享 API Key
项目配置：项目 API Key
用户配置：Alice 个人 API Key ✅

结果：Alice 的所有 Agent 调用使用她自己的 API Key
```

**场景 2：Bob 使用项目配置**

```
全局配置：团队共享 API Key
项目配置：项目专用 API Key ✅
用户配置：Bob 未设置

结果：Bob 在该项目中的 Agent 调用使用项目配置
```

**场景 3：Charlie 使用全局配置**

```
全局配置：团队共享 API Key ✅
项目配置：未设置
用户配置：Charlie 未设置

结果：Charlie 的 Agent 调用使用全局配置
```

### 支持的 LLM 提供商

当前系统支持：

| 提供商 | Provider 值 | 适用场景 |
|--------|-----------|----------|
| **智谱 AI** | `glm` | 默认，中文优化 |
| **OpenAI** | `openai` | 可选，需配置 API Key |

### 配置参数说明

| 参数 | 说明 | 默认值 | 建议值 |
|------|------|--------|--------|
| `api_key` | API 密钥 | 必填 | - |
| `base_url` | API 基础 URL | 智谱/OpenAI | - |
| `model` | 模型名称 | glm-4-plus | glm-4-plus/gpt-4 |
| `temperature` | 温度（0-1） | 0.7 | 0.7（创造性） |
| `max_tokens` | 最大输出 tokens | 4096 | 4096-8192 |

### API Key 安全

- **显示保护**：界面中显示为 `sk-1...cdef` 格式
- **密码输入**：使用 `type="password"` 输入框
- **传输加密**：HTTPS 传输
- **存储加密**：数据库加密存储
- **不记录日志**：Agent 执行日志中不包含完整 API Key

---

## ADSE 增强模式

### 什么是 ADSE？

**ADSE（AI-Driven Software Engineering）** 是一种通过**逻辑压制代码**的软件工程新范式。核心理念是：不再把代码当成核心资产，而是把**"定义代码生成的逻辑指令"**当成看家本领。

### 核心方法论：落地三板斧

| 步骤 | 名称 | 目标 | 示例 |
|------|------|------|------|
| **立法** | Meta-Prompting | 把经验变成AI无法违背的逻辑指令 | "所有接口必须包含异常处理""数据库查询必须加索引" |
| **筑墙** | Constraints | 强制定义物理目录结构和协议插槽 | 核心逻辑和扩展功能严格分离 |
| **审计** | Logic Audit | 反向解构业务意图，与原始需求比对 | 确保AI生成的代码可理解、可追溯 |

### 四象限需求法

ADSE 的核心是**四象限需求录入**，系统化地消除逻辑盲区：

| 象限 | 关注点 | 引导问题 | 示例 |
|------|--------|----------|------|
| **功能核心** | 业务的主路径与终态 | 系统要解决的"第一核心"是什么？ | 用户通过API完成CRUD操作 |
| **物理约束** | 技术栈、性能与环境 | 必须使用什么框架？文件存放在哪？ | FastAPI + PostgreSQL，QPS > 1000 |
| **语义契约** | 逻辑法则与安全边界 | 哪些动作是绝对禁止的？ | 所有接口必须包含异常处理 |
| **异常与边缘** | 逻辑的暗角与鲁棒性 | 支付超时怎么办？ | API超时返回504，触发告警 |

### 如何启用 ADSE 增强模式

#### 1. 创建 Slice 时启用

在创建 Slice 时，勾选 **"启用 ADSE 增强模式"**：

```
┌─────────────────────────────────────────────────────────────┐
│  创建 Slice                                                  │
├─────────────────────────────────────────────────────────────┤
│  标题: [输入标题]                                            │
│  范围: [输入范围]                                            │
│  超出范围: [输入超出范围]                                    │
│                                                             │
│  ☑ 启用 ADSE 增强模式（四象限需求法）                        │
│    ADSE 方法论通过结构化需求提升 AI 生成代码的质量。          │
│    推荐高级用户使用。                                        │
│                                                             │
│  ┌─ 四象限需求 ──────────────────────────────────────────┐  │
│  │ 模板类型: [Web API ▼]                                 │  │
│  │                                                         │  │
│  │ 功能核心:                                              │  │
│  │ [系统要解决的核心业务问题是什么？...]                  │  │
│  │                                                         │  │
│  │ 物理约束:                                              │  │
│  │ [技术栈和环境约束...]                                  │  │
│  │                                                         │  │
│  │ 语义契约（逻辑规则）*                                  │  │
│  │ [AI生成代码时必须遵守的逻辑规则...]                    │  │
│  │ 这些规则将在AI生成代码时被严格执行                     │  │
│  │                                                         │  │
│  │ 异常与边缘:                                            │  │
│  │ [异常处理和边缘情况...]                                │  │
│  └─────────────────────────────────────────────────────┘  │
│                                                             │
│  [创建 Slice]                                               │
└─────────────────────────────────────────────────────────────┘
```

#### 2. 使用模板快速填充

系统提供 4 种预设模板：

| 模板 | 适用场景 |
|------|----------|
| **Web API** | 后端 API 服务 |
| **前端应用** | React/Vue 等前端项目 |
| **后端服务** | 微服务、后台任务 |
| **数据管道** | ETL、数据处理流程 |

#### 3. 自定义四象限内容

根据项目实际情况，修改模板内容或手动填写四象限。

**⚠️ 重要提示**：**语义契约**是最重要的部分，这些规则将被 AI 严格执行。

### ADSE 与普通模式的对比

| 维度 | 普通模式 | ADSE 增强模式 |
|------|---------|--------------|
| **需求输入** | scope / out_of_scope | 四象限结构化需求 |
| **提示词生成** | 静态模板 | 动态 Meta-Prompt |
| **代码质量** | 基础保障 | 逻辑确定性保障 |
| **适用场景** | 快速原型、简单功能 | 生产级项目、复杂系统 |
| **学习成本** | 低 | 中（需理解四象限） |

### ADSE 的核心价值

#### 1. 消灭黑盒
每一行 AI 生成的代码都能追溯到对应的逻辑指令，看得懂、管得住。

#### 2. 逻辑资产化
指令集是核心资产，代码可以随用随弃。换项目、换 AI 模型，拿着指令集就能瞬间重建系统。

#### 3. 降维打击提效
把高级架构师的经验直接转化为生产力，初中级开发者不用再重复造轮子。

### 实际案例：使用 ADSE 开发用户评论功能

#### 普通模式

```
范围：实现用户评论功能
超出范围：用户管理、内容审核

→ AI 生成代码，可能缺少异常处理、性能优化...
```

#### ADSE 增强模式

```
功能核心：
- 用户可以对商品发表评论
- 评论包含评分（1-5星）和文字内容
- 其他用户可以查看评论列表

物理约束：
- 框架: FastAPI + SQLAlchemy
- 数据库: PostgreSQL
- 缓存: Redis
- 性能: 支持每秒1000次评论查询

语义契约（最重要的部分）：
- 所有数据库操作必须在事务中执行
- 评论内容必须过滤XSS，防止注入攻击
- 评论查询必须使用缓存，TTL=300秒
- 敏感词必须被过滤（使用外部API）
- 所有API必须设置超时时间（5秒）

异常与边缘：
- 数据库连接失败：降级到缓存，返回提示
- 敏感词API超时：记录日志，评论进入待审核队列
- 用户重复提交：返回409 Conflict，提示用户

→ AI 生成的代码严格遵守所有规则，代码质量显著提升
```

### 何时使用 ADSE？

#### ✅ 推荐使用 ADSE

- 生产级项目
- 复杂业务逻辑
- 需要严格代码规范
- 多人协作项目
- 长期维护的项目

#### ❌ 不需要 ADSE

- 快速原型开发
- 简单脚本工具
- 学习测试项目
- 一次性任务

### ADSE 工具链

当启用 ADSE 增强模式后，系统会自动初始化三大工具来跟踪和审计 AI 生成的代码：

#### 1. P2C 追踪矩阵 (Prompt-to-Code Tracking Matrix)

**作用**：建立逻辑指令与代码物理文件的映射关系

| 字段 | 说明 |
|------|------|
| 指令ID | 自动生成的唯一标识符（如 SC-001） |
| 类别 | 语义契约、功能核心、物理约束、异常处理 |
| 逻辑约束描述 | 从四象限中提取的具体规则 |
| 目标文件 | AI 生成的代码文件路径 |
| 状态 | 待处理、待审计、已合规、不合规 |

**示例**：

```
| 指令ID   | 类别     | 逻辑约束描述                              | 目标文件              | 状态     |
|----------|----------|------------------------------------------|----------------------|----------|
| SC-001   | 语义契约 | 所有接口必须包含异常处理                 | /api/users.py        | 已合规   |
| SC-002   | 语义契约 | 数据库查询必须加索引                     | /models/user.py      | 待审计   |
| PC-001   | 物理约束 | 使用 FastAPI 框架                         | /main.py             | 已合规   |
| EX-001   | 异常处理 | API 超时返回 504                          | /middleware/timeout.py| 待处理   |
```

**自动工作流程**：
1. 创建 ADSE Slice 时，自动从四象限中提取逻辑规则
2. Agent 执行后，自动将生成的文件映射到相关规则
3. 根据映射结果更新状态（待审计、已合规等）

#### 2. 逻辑覆盖度审计表 (Logic Coverage Audit)

**作用**：衡量 AI 生成的代码在多大程度上满足了元提示词中的法律条文

**审计时机**：Dev Agent 执行完成后自动运行

**审计维度**：

| 维度 | 说明 | 示例 |
|------|------|------|
| 总规则数 | 语义契约中的逻辑规则总数 | 10 条规则 |
| 通过规则数 | 代码中找到对应的实现 | 7 条通过 |
| 失败规则数 | 未找到实现或实现不完整 | 3 条失败 |
| 覆盖率 | 通过规则占比 | 70% |

**审计结果示例**：

```
## 语义契约审计报告

总规则: 10 · 通过: 7 · 失败: 3
覆盖率: 70.0%

详细发现:
✅ SC-001: 所有接口必须包含异常处理
   通过: 在 /api/users.py 中找到 try-except 块

✅ SC-002: 敏感数据必须加密存储
   通过: 在 /models/user.py 中使用 bcrypt

❌ SC-003: 数据库查询必须加索引
   失败: User.email 字段缺少索引定义

❌ SC-005: 所有 API 必须设置 5 秒超时
   失败: 未找到超时配置
```

**如何使用**：
1. 查看 Slice 详情页的审计报告
2. 点击"查看详细发现"查看每条规则的检查结果
3. 对于失败的规则，重新运行 Agent 或手动修复代码
4. 审计报告会保存历史记录，可以追踪改进过程

#### 3. ADSE 项目控制表 2.0

**作用**：全生命周期跟踪能力，确保从需求到代码的完整可追溯性

**四层控制架构**：

| 层级 | 控制重点 | 示例控制项 | 验收准则 |
|------|----------|-----------|---------|
| **基础层** | 环境与物理约束 | 技术栈规范、性能要求、环境约束 | `/core` 严禁被业务 Hook 修改 |
| **契约层** | 语义契约与暗知识 | 语义契约规则、P2C 追踪 ID | 核心逻辑必须符合「确定性」 |
| **插槽层** | Hooks 定义 | 状态变更 Hook、数据验证 Hook | 所有状态变更必须触发对应 Hook |
| **防护层** | 负向约束 | 禁止的 Anti-pattern、安全边界 | 代码中不得出现 Anti-pattern 清单 |

**控制指标**：

```
总控制项: 15
已验证: 8
覆盖率: 53.3%

按层级分布:
- 基础层: 4 项
- 契约层: 5 项
- 插槽层: 3 项
- 防护层: 3 项
```

**使用场景**：
- **项目启动时**：检查所有控制项是否已定义
- **开发过程中**：验证控制项是否被正确实现
- **代码审查时**：对照控制表逐项检查
- **上线前审计**：确保所有关键控制项已验证

### ADSE 工具链完整工作流

```
┌─────────────────────────────────────────────────────────────────┐
│  1. 用户创建 Slice（启用 ADSE）                                  │
│     ├─ 填写四象限需求                                            │
│     ├─ 选择模板类型（可选）                                      │
│     └─ 系统自动初始化工具链                                      │
├─────────────────────────────────────────────────────────────────┤
│  2. 系统自动创建 P2C 追踪项                                     │
│     └─ 从四象限中提取逻辑规则，生成追踪矩阵                       │
├─────────────────────────────────────────────────────────────────┤
│  3. 系统自动初始化项目控制表                                   │
│     └─ 创建四层控制架构的检查项                                 │
├─────────────────────────────────────────────────────────────────┤
│  4. 运行 Agent（PM/Architect/Dev）                              │
│     └─ 使用 ADSE 增强的 Meta-Prompt 生成代码                    │
├─────────────────────────────────────────────────────────────────┤
│  5. 系统自动更新 P2C 追踪                                      │
│     └─ 将生成的文件映射到逻辑规则                               │
├─────────────────────────────────────────────────────────────────┤
│  6. Dev 完成后自动运行逻辑审计                                 │
│     └─ 检查代码对语义契约的满足程度                             │
├─────────────────────────────────────────────────────────────────┤
│  7. 用户查看工具链报告                                         │
│     ├─ P2C 追踪矩阵：查看规则与文件的映射                      │
│     ├─ 审计报告：查看逻辑覆盖度                                │
│     └─ 项目控制表：查看四层控制项状态                          │
├─────────────────────────────────────────────────────────────────┤
│  8. 迭代优化                                                   │
│     └─ 根据审计结果调整规则或重新生成代码                       │
└─────────────────────────────────────────────────────────────────┘
```

### ADSE 资源与参考

ADSE 方法论由 [@超哥践行](https://mp.weixin.qq.com/s/JxhiCH3GEJeNwmM0iPhPxA) 提出，相关文章：

- [什么是ADSE？逻辑驱动的软件工程新范式](https://mp.weixin.qq.com/s/JxhiCH3GEJeNwmM0iPhPxA)
- [让AI编程可控可管的ADSE落地工具链](https://mp.weixin.qq.com/s/W8r0bJs-xZ6cq0OX1-AF2Q)

---

## 质量门禁

### 默认门禁

| 门禁 | 命令 | 用途 |
|------|------|------|
| **lint** | `make lint` | 代码风格检查（如 flake8、black） |
| **type** | `make type` | 类型检查（如 mypy） |
| **contract** | `make contract` | API 契约验证（如 OpenAPI 规范） |
| **test** | `make test` | 单元和集成测试 |

---

## GitHub 集成

### 配置 GitHub Token

```bash
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
```

或添加到 `.env` 文件：

```
GITHUB_TOKEN=ghp_xxxxxxxxxxxx
```

---

## 最佳实践

### LLM 配置策略

**个人开发者**：
- 使用全局配置（.env 文件）
- 一个 API Key 即可

**小团队**：
- 建议使用全局配置
- 团队共享费用，统一管理

**中大型团队**：
- 使用用户级配置
- 每个开发者使用自己的 API Key
- 费用独立核算

**项目制团队**：
- 使用项目级配置
- 按项目核算成本
- 客户项目可单独计费

**混合模式**（最灵活）：
- 大多数成员使用全局/项目配置
- 核心开发者使用个人配置进行实验

### Slice 设计

✅ **好的 Slice**：
- 范围明确，可在 1-3 天内完成
- 验收标准清晰可测
- 风险级别评估准确

❌ **不好的 Slice**：
- 范围过大，包含多个独立功能
- 验收标准模糊
- 低估风险级别

### 验收标准编写

使用 **SMART 原则**：

- **Specific**: 具体明确
- **Measurable**: 可度量
- **Achievable**: 可实现
- **Relevant**: 相关性
- **Time-bound**: 有时限

### AI 辅助开发流程

1. **准备阶段**：设定清晰的验收标准
2. **生成阶段**：让 AI 生成初稿
3. **审核阶段**：人工审核 AI 产出
4. **迭代阶段**：不满意就重新运行
5. **手动调整**：必要时直接编辑文件

**三种迭代方式**：

1. **重新运行 Agent**（带补充说明）
   - 适用：AI 遗漏了某些需求
   - 操作：补充 AC 或说明，重新 Run

2. **直接编辑文件**
   - 适用：小的调整
   - 操作：进入 worktree 直接编辑

3. **人工草稿 + AI 完善**
   - 适用：需要人类创意
   - 操作：人工创建框架，AI 填充内容

---

## 实战案例：为电商系统添加用户评论功能

本节通过一个完整案例，展示如何使用 Agent Dev Dashboard + GLM-4.7 进行实际的开发工作。

### 📋 案例背景

**项目**: 电商后端服务 `ecommerce-api`
**任务**: 添加用户商品评论功能
**团队**: 3 人（Alice 作为 Owner，Bob 和 Charlie 作为 Member）
**AI**: 智谱 GLM-4.7 大模型

### 第一步：创建项目并邀请成员

#### 1.1 Alice 创建项目

登录系统后，在首页填写：

| 字段 | 值 |
|------|-----|
| Project name | ecommerce-api |
| Repo URL | git@github.com:acme/ecommerce-api.git |
| Default branch | main |

系统自动克隆仓库到本地。

#### 1.2 Alice 邀请团队成员

**使用邀请码系统**：

1. Alice 进入项目详情页
2. 在 Invitations 区块设置：
   - 有效期：7 天
3. 点击 "Create Invitation"
4. 系统生成邀请码：`ABCD1234EFGH`
5. Alice 将邀请码通过 IM/邮件发送给 Bob 和 Charlie

**Bob 注册**：

1. 访问系统，点击登录
2. 看到注册表单，输入：
   - 用户名：bob
   - 密码：******
   - 邀请码：`ABCD1234EFGH`
3. 点击 "Create User"

**Charlie 注册**：使用相同流程

### 第二步：配置 LLM

**Alice 设置项目级 LLM 配置**（项目费用统一核算）：

1. Alice 进入项目详情页
2. 在 LLM Configuration 区块填写：
   - Provider: GLM (Zhipu AI)
   - API Key: 项目专用 API Key
   - Base URL: https://open.bigmodel.cn/api/paas/v4/
   - Model: glm-4-plus
   - Temperature: 0.7
   - Max Tokens: 4096
3. 点击 "Save Configuration"

**结果**：该项目所有 Agent 调用都使用项目配置，费用统一核算到项目。

### 第三步：创建 Slice

Alice 创建一个新的开发 Slice：

| 字段 | 填写内容 |
|------|----------|
| **Title** | 添加用户商品评论功能 |
| **Scope** | 用户可以对商品发表评论、评分、查看评论列表；管理员可以删除不当评论 |
| **Out of Scope** | 不包含评论点赞、评论回复、图片上传功能 |
| **Risk Level** | low-write |

### 第四步：设定验收标准

Alice 在 Slice 详情页添加验收标准：

```
Code: AC-001
Text: 用户可以查看指定商品的所有评论
Verification: GET /api/products/{id}/reviews 返回评论列表

Code: AC-002
Text: 用户可以提交商品评论（评分 1-5 星 + 文字内容）
Verification: POST /api/products/{id}/reviews 创建评论，数据库验证
```

### 第五步：生成上下文包

Bob 点击 **"Generate Context Pack"**，系统自动收集上下文信息。

### 第六步：执行 PM Agent（AI 辅助需求分析）

#### 6.1 Bob 触发 AI Agent

点击 **PM → Run**。

**系统后台执行流程**：

```
1. 创建独立的 Git Worktree
   ├── 路径: workspace/project_1/worktrees/run_1_slice_0001/
   └── 基于 branch: slice-1-add-product-comments

2. 获取有效 LLM 配置（项目级配置）
   └── API Key: 项目专用 API Key
       └── Model: glm-4-plus

3. 调用 PM Agent（使用 GLM-4.7）
   ├── 输入: Context Pack + 验收标准 + 现有代码
   ├── System Prompt: "你是一位经验丰富的产品经理..."
   ├── User Prompt: 详细的需求描述和 AC
   │
   └── GLM-4.7 输出: AI 生成的 PRD 文档

4. 写入文件
   ├── docs/PRD.md (PM Agent 生成的 PRD)
   ├── docs/ACCEPTANCE.md (验收标准文档)
   └── tasks/0001-slice-1.md (任务卡片)

5. Git 自动提交
   └── commit: "slice 1: pm artifacts"
```

#### 6.2 GLM-4.7 生成的 PRD 文档

**AI 生成的 PRD**：

```markdown
📁 docs/PRD.md
## Slice 1: 添加用户商品评论功能

### 背景与目标
- 背景：当前电商系统缺少用户互动功能，无法了解用户对商品的真实反馈
- 目标：增加用户评论功能，提升购买转化率和用户参与度

### 用户故事
- US-001 作为买家，我希望查看商品评论，以便做出购买决策
- US-002 作为买家，我希望发表商品评论，以便分享使用体验
- US-003 作为管理员，我希望管理不当评论，以便维护社区氛围

### 业务规则
- 规则：
  - 每个用户对每个商品只能评论一次
  - 评论内容长度限制在 500 字以内
  - 评论需要管理员审核后才能公开显示
  - 评分范围 1-5 星
- 边界：
  - 不支持评论编辑和删除（用户）
  - 不支持评论回复和点赞
- 异常流程：
  - 评论提交失败返回 400 错误
  - 重复评论返回提示信息
```

#### 6.3 Bob 审核并迭代

**Bob 发现的问题**：
- ❌ 缺少评论内容审核机制

**Bob 的处理**（方式 A：重新运行）：

1. Bob 在 AC 中补充：
   ```
   Code: AC-006
   Text: 管理员审核后评论才公开
   Verification: 新建评论默认状态为 pending
   ```

2. 重新点击 **PM → Run**

3. GLM-4.7 根据补充的 AC 更新了文档：
   ```markdown
   ### 业务规则
   - 规则：
     - 每个用户对每个商品只能评论一次
     - 评论内容长度限制在 500 字以内
     - 评论需要管理员审核后才能公开显示 ⭐ 新增
     - 评分范围 1-5 星
   ```

**Bob 确认**：PRD 现在完整了，继续下一步。

### 第七步：执行 Architect Agent（AI 辅助架构设计）

#### 7.1 Bob 触发 AI Agent

点击 **Architect → Run**。

**GLM-4.7 生成的架构文档**：

```markdown
📁 docs/DESIGN.md
## Slice 1: 添加用户商品评论功能

### 系统架构
- 整体架构：分层架构（Controller → Service → Repository）
- 模块划分：reviews API 模块、Review 数据模型

### API 契约
- RESTful API 设计
- 请求/响应格式：JSON
- 错误码定义

### 数据模型
```

**GLM-4.7 生成的 OpenAPI 规范**：

```yaml
📁 contracts/openapi.yaml
openapi: 3.0.0
info:
  title: Product Reviews API
  version: 1.0.0
paths:
  /api/products/{id}/reviews:
    get:
      summary: 获取商品评论列表
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
        - name: page
          in: query
          schema:
            type: integer
            default: 1
      responses:
        200:
          description: 成功
```

### 第八步：执行 Dev Agent（AI 辅助代码开发）

#### 8.1 Charlie 触发 AI Agent

点击 **Dev → Run**。

**GLM-4.7 生成的代码**：

```python
📁 src/models/review.py
from datetime import datetime
from sqlalchemy import Column, Integer, Text, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from src.db import Base

class Review(Base):
    __tablename__ = 'reviews'

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    product_id = Column(Integer, ForeignKey('products.id'), nullable=False)
    rating = Column(Integer, nullable=False)
    content = Column(Text, nullable=False)
    status = Column(String(20), default='pending')
    created_at = Column(DateTime, default=datetime.utcnow)

    # 关系
    user = relationship("User", back_populates="reviews")
    product = relationship("Product", back_populates="reviews")
```

```python
📁 src/api/reviews.py
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, validator

class ReviewCreate(BaseModel):
    rating: int
    content: str

    @validator('rating')
    def validate_rating(cls, v):
        if not 1 <= v <= 5:
            raise ValueError('Rating must be between 1 and 5')
        return v

@router.post("/{product_id}/reviews", status_code=201)
def create_review(
    product_id: int,
    review: ReviewCreate,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """创建商品评论"""
    # Pydantic 自动验证评分

    # 检查重复评论
    existing = db.query(Review).filter(
        Review.user_id == current_user['id'],
        Review.product_id == product_id
    ).first()

    if existing:
        raise HTTPException(
            status_code=400,
            detail="User has already reviewed this product"
        )

    # 创建评论
    new_review = Review(
        user_id=current_user['id'],
        product_id=product_id,
        rating=review.rating,
        content=review.content,
        status='pending'  # 默认待审核
    )

    db.add(new_review)
    db.commit()

    return new_review
```

### 第九步：执行 QA Agent（AI 辅助测试）

#### 9.1 Charlie 触发 AI Agent

点击 **QA → Run**。

**GLM-4.7 生成的测试用例**：

```python
📁 tests/integration/test_reviews_api.py
import pytest
from fastapi.testclient import TestClient

def test_get_reviews_pagination(client: TestClient, db_session):
    """测试评论列表分页（AC-005）"""
    # 准备 25 条评论
    for i in range(25):
        review = Review(
            product_id=1,
            user_id=i,
            rating=5,
            content="Test",
            status='approved'
        )
        db_session.add(review)
    db_session.commit()

    # 请求第一页
    response = client.get("/api/products/1/reviews?page=1&page_size=20")
    assert response.status_code == 200

    data = response.json()
    assert data['total'] == 25
    assert data['page'] == 1
    assert len(data['data']) == 20

def test_create_review_success(client: TestClient, auth_headers):
    """测试成功创建评论（AC-002）"""
    response = client.post(
        "/api/products/1/reviews",
        json={"rating": 5, "content": "Great product!"},
        headers=auth_headers
    )
    assert response.status_code == 201

    data = response.json()
    assert data['rating'] == 5
    assert data['status'] == 'pending'  # 待审核
```

### 第十步：执行 Ops Agent（AI 辅助运维文档）

点击 **Ops → Run**。

**GLM-4.7 生成的部署文档**：

```markdown
📁 docs/DEPLOY.md
# 评论功能部署指南

## 数据库迁移
```sql
CREATE TABLE reviews (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id),
    product_id INTEGER NOT NULL REFERENCES products(id),
    rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
    content TEXT NOT NULL,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_review_product ON reviews(product_id);
CREATE INDEX idx_review_user ON reviews(user_id);
CREATE INDEX idx_review_status ON reviews(status);

-- 防止用户重复评论
CREATE UNIQUE INDEX idx_review_user_product ON reviews(user_id, product_id);
```

## 环境变量
```bash
REVIEW_MAX_LENGTH=500
REVIEW_MIN_RATING=1
REVIEW_MAX_RATING=5
```

### AI 辅助开发流程总结

#### 人机协作模式

```
┌─────────────────────────────────────────────────────────┐
│                    人机协作流程                          │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  人类 (Alice/Bob/Charlie)          AI Agent (GLM-4.7)     │
│  ─────────────────────           ────────────────       │
│                                                          │
│  1. 设定目标和验收标准                                  │
│                 │                                        │
│                 ▼                                        │
│  2. 触发 Agent ───────────────────→ 接收 Context Pack    │
│   (点击 Run 按钮)                  和 Prompt             │
│                                                          │
│                 │                                        │
│                 │      GLM-4.7 生成文档/代码              │
│                 │           (智谱 AI)                   │
│                 │                                        │
│                 ▼                                        │
│  3. 审核 AI 产出  ←───────────────── 返回结果            │
│                                                          │
│     满意？                                              │
│      │                                                  │
│      ├── 是 → 继续下一步                                 │
│      │                                                  │
│      └── 否 → 提供反馈 ───────────→ 重新生成             │
│                  (补充说明)      (迭代优化)              │
│                                                          │
│  4. 必要时手动调整                                       │
│     (直接编辑文件)                                      │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

#### 关键要点

| 环节 | 人类职责 | AI 职责 | 协作方式 |
|------|----------|---------|----------|
| **需求分析** | 设定验收标准、明确范围 | 分析需求、生成 PRD | 人类审核、AI 迭代 |
| **架构设计** | 审查设计合理性 | 设计数据模型、API 规范 | 人类反馈、AI 优化 |
| **代码开发** | 审查代码质量、处理边界 | 实现核心功能代码 | 人类调整、AI 补充 |
| **测试设计** | 定义测试场景 | 生成测试用例代码 | 人类补充、AI 完善 |
| **运维文档** | 审查可操作性 | 生成部署和运维文档 | 人类确认、AI 调整 |

#### 迭代优化的三种方式

1. **重新运行 Agent**（带补充说明）
   - 适合：AI 遗漏了某些需求
   - 操作：在 AC 中补充，重新点击 Run

2. **直接编辑文件**（手动修改）
   - 适合：小的调整或个性化需求
   - 操作：进入 worktree 直接编辑

3. **人工介入后再运行**
   - 适合：需要人类创意或复杂决策
   - 操作：人工创建草稿，AI 继续完成

---

## 常见问题

### Q: 如何获取智谱 AI API Key？

A:
1. 访问 [智谱 AI 开放平台](https://open.bigmodel.cn/)
2. 注册/登录账户
3. 在 API Keys 页面创建新的 API Key
4. 将 API Key 复制到 `.env` 文件或用户设置中

### Q: 如何切换到英文界面？

A: 点击页面右上角的 **EN** 按钮即可切换到英文。

### Q: 团队成员如何使用自己的 API Key？

A:
1. 团队成员登录后，点击顶部导航栏的 "Settings"
2. 在 LLM Configuration 区块填写个人 API Key
3. 保存配置
4. 之后该成员的所有 Agent 调用都将使用其个人配置

### Q: 项目配置和用户配置的优先级是怎样的？

A: 用户配置 > 项目配置 > 全局配置。当用户设置了个人配置时，会优先使用个人配置，忽略项目和全局配置。

### Q: Agent 执行失败怎么办？

A:
1. 查看 Slice 详情页 → Runs 区块
2. 找到失败的 Run，查看 log 输出
3. 检查是否是 API Key 问题或网络问题
4. 根据错误信息调整后重新执行

### Q: 如何清理旧的 Worktree？

A: Worktree 会自动清理。如需手动清理：
```bash
cd workspace
rm -rf <worktree-path>
```

### Q: 可以同时运行多个 Agent 吗？

A: 可以。系统使用 Git Worktree 隔离环境，多个 Agent 可以并行执行。

### Q: 门禁失败了怎么办？

A:
1. 查看 Gates 区块的具体输出
2. 修复相应问题
3. 提交修复
4. 重新运行门禁

### Q: 如何添加新的 Agent 角色？

A: 修改以下文件：
1. `app/agents.py`: 添加新的 Agent 函数
2. `app/config.py`: 配置角色路径权限
3. `app/main.py`: 更新状态机转换

### Q: 智谱 GLM-4.7 和其他模型相比如何？

A: GLM-4.7 是智谱 AI 的最新模型，在中文理解和生成方面表现优秀，特别适合中文场景的开发。系统也支持配置 OpenAI 等其他模型。

### Q: 费用如何计算？

A:
- **全局配置**：所有用户共享一个 API Key，费用统一
- **用户级配置**：每个用户使用自己的 API Key，费用独立
- **项目级配置**：项目成员共享一个 API Key，按项目核算

---

## 获取帮助

- GitHub Issues: [项目地址]
- 文档: `docs/` 目录
- 智谱 AI: https://open.bigmodel.cn/

---

**版本**: v2.0.0
**更新日期**: 2025-01-29
**新特性**:
- ✨ GLM-4.7 大模型集成
- ✨ 三层 LLM 配置（用户/项目/全局）
- ✨ 邀请码注册系统
- ✨ 多语言支持（中英文）
